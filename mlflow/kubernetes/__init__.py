import os
import yaml
from subprocess import Popen 

import mlflow
from mlflow.tracking.utils import _get_model_log_dir
from mlflow.utils.file_utils import TempDir, _copy_file_or_tree 
from mlflow.utils.docker import get_template, build_image 
from mlflow.utils.docker import push_image as push_docker_image

MODEL_SERVER_INTERNAL_PORT = 8080
DEFAULT_SERVICE_PORT = 5001

SERVICE_TYPE_LOAD_BALANCER = "LoadBalancer"
SERVICE_TYPE_NODE_PORT = "NodePort"
SERVICE_TYPE_CLUSTER_IP = "ClusterIP"

SERVICE_TYPES = [
    SERVICE_TYPE_LOAD_BALANCER,
    SERVICE_TYPE_NODE_PORT,
    SERVICE_TYPE_CLUSTER_IP
]

APPLICATION_CONFIG_SUBPATH = "server_config.yaml"

DEPLOYMENT_CONFIG_TEMPLATE = """\
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {app_name} 
  labels:
    app: {app_name} 
spec:
  replicas: 1 
  selector:
    matchLabels:
      app: {app_name} 
  template:
    metadata:
      labels:
        app: {app_name} 
    spec:
      containers:
      - name: {app_name}
        image: {image_uri} 
        args: ["serve"]
        ports:
        - containerPort: {internal_port} 
"""

SERVICE_CONFIG_TEMPLATE = """\
apiVersion: v1
kind: Service
metadata:
  name: {app_name}
spec:
  type: {service_type}
  selector:
    app: {app_name} 
  ports:
  - name: {app_name}-port
    protocol: TCP
    port: {service_port} 
    targetPort: {internal_port} 
"""


class ApplicationConfig:

    def __init__(self, model_path, image_uri, run_id=None):
        self.image_uri = image_uri
        self.model_path = model_path
        self.run_id = run_id
        
    def to_yaml(self, stream=None):
        return yaml.safe_dump(self.__dict__, stream=stream, default_flow_style=False)
    

    def save(self, path):
        with open(path, "w") as f:
            self.to_yaml(stream=f)


    @classmethod
    def load(cls, path):
        with open(path, "r") as f:
            return cls(**yaml.safe_load(f.read()))


def deploy(app_name, config_path, replicas=1, image_pull_secret=None, 
           service_type=SERVICE_TYPE_LOAD_BALANCER, service_port=None, log_directory=None):
    """
    :param app_name: The name to give the deployed application. This will be used for naming the 
                     Kubernetes services and deployments that are created.
    :param config_path: The path to the model application configuration generated by 
                        `mlflow.kubernetes.build_serving_application`.
    :param replicas: The number of model replicas to deploy.
    :param image_pull_secret: The name of a Kubernetes secret that will be used to pull images
                              from the Docker registry specified by `target_registry_uri`.
    :param service_type: The type of Kubernetes service to use for exposing the model. This must be
                         one of the values specified `mlflow.kubernetes.SERVICE_TYPES`, which
                         correspond to Kubernetes service types outlined here:
                         https://kubernetes.io/docs/concepts/services-networking/service/
                         #publishing-services-service-types.
    :param service_port: The cluster node port on which to expose the Kubernetes service for model 
                         serving. This value will be used for the `port` field of the Kubernetes
                         service spec (see mlflow.kubernetes.SERVICE_CONFIG_TEMPLATE for reference).
                         If `None`, the port defined by `mlflow.kubernetes.DEFAULT_SERVICE_PORT`
                         will be used.
    :param log_directory: If specified, Kubernetes configuration files generated during deployment
                          will be logged to this directory. The directory must not already exist. 
    """
    if service_type not in SERVICE_TYPES:
        raise Exception("The specified `service_type` value: `{specified_service_type}` is not"
                         " supported. the value must be one of: {supported_service_types}".format(
                             specified_service_type=service_type,
                             supported_service_types=SERVICE_TYPES)) 

    application_config = ApplicationConfig.load(config_path)
    with TempDir() as tmp:
        cwd = tmp.path()

        deployment_config_path = os.path.join(
                cwd, "{app_name}_deployment_config.yaml".format(app_name=app_name))
        deployment_config = _get_deployment_config(
                app_name=app_name, image_uri=application_config.image_uri, 
                internal_port=MODEL_SERVER_INTERNAL_PORT)
        if image_pull_secret is not None:
            _add_image_pull_secret(
                    deployment_config=deployment_config, secret_name=image_pull_secret)
        with open(deployment_config_path, "w") as f:
            f.write(deployment_config)

        service_config_path = os.path.join(
                cwd, "{app_name}_service_config.yaml".format(app_name=app_name))
        service_port = service_port if service_port is not None else DEFAULT_SERVICE_PORT
        service_config = _get_service_config(
                app_name=app_name, service_type=service_type, service_port=service_port, 
                internal_port=MODEL_SERVER_INTERNAL_PORT)
        with open(service_config_path, "w") as f:
            f.write(service_config)

        base_cmd = "kubectl apply -f {config_path}"
        deployment_cmd = base_cmd.format(config_path=deployment_config_path)
        service_cmd = base_cmd.format(config_path=service_config_path)

        print(deployment_cmd)
        deployment_proc = Popen(deployment_cmd.split(" "))
        deployment_proc.wait()

        print(service_cmd)
        service_proc = Popen(service_cmd.split(" "))
        service_proc.wait()

        deployment_config = _load_kubernetes_config(config_path=deployment_config_path)
        deployment_name = deployment_config["metadata"]["name"]
        autoscale_cmd = ("kubectl scale deployment {deployment_name}" 
                         " --replicas={num_replicas}").format(
                                deployment_name=deployment_name, num_replicas=replicas)
        print(autoscale_cmd)
        autoscale_proc = Popen(autoscale_cmd.split(" "))
        autoscale_proc.wait()

        if log_directory is not None:
            log_directory = os.path.abspath(log_directory)
            print("Logging generated Kubernetes configurations to: {log_directory}".format(
                log_directory=log_directory))
            os.makedirs(log_directory)
            _copy_file_or_tree(deployment_config_path, log_directory, None)
            _copy_file_or_tree(service_config_path, log_directory, None)


def build_serving_application(model_path, run_id=None, pyfunc_image_uri=None, mlflow_home=None, 
                              target_registry_uri=None, push_image=False, output_file=None):
    """
    :param model_path: The path to the Mlflow model for which to build a server.
                       If `run_id` is not `None`, this should be an absolute path. Otherwise,
                       it should be a run-relative path.
    :param run_id: The run id of the Mlflow model for which to build a server.
    :param pyfunc_image_uri: URI of an `mlflow-pyfunc` base Docker image from which the model server 
                             Docker image will be built. If `None`, the base image will be
                             built from scratch.
    :param mlflow_home: Path to the Mlflow root directory. This will only be used if the container
                        base image is being built from scratch (if `pyfunc_image_uri` is `None`).
                        If `mlflow_home` is `None`, the base image will install Mlflow from pip
                        during the build. Otherwise, it will install Mlflow from the specified
                        directory.
    :param target_registry_uri: The URI of the docker registry that Kubernetes will use to
                                pull the model server Docker image. If `None`, the default
                                docker registry (docker.io) will be used. Otherwise, the model 
                                server image will be tagged using the specified registry uri.
    :param push_image: If `True`, the model server Docker image will be pushed to the registry
                       specified by `target_registry_uri` (or docker.io if `target_registry_uri` is
                       `None`). If `False`, the model server Docker image will not be
                       pushed to a registry.
    :param output_file: The name of the configuration file containing application information.
                        If `None`, a name will be generated using the specified `model_path` and
                        `run_id`.
    """
    with TempDir() as tmp:
        cwd = tmp.path()
        dockerfile_template = _get_image_template(image_resources_path=cwd, 
                model_path=model_path, run_id=run_id, pyfunc_uri=pyfunc_image_uri, 
                mlflow_home=mlflow_home)

        template_path = os.path.join(cwd, "Dockerfile")
        with open(template_path, "w") as f:
            f.write(dockerfile_template)
        
        model_id = _get_model_id(run_id=run_id)
        image_name = "mlflow-model-{model_id}".format(model_id=model_id)
        if target_registry_uri is not None:
            image_uri = "/".join([target_registry_uri.strip("/"), image_name])
        else:
            image_uri = image_name
        
        build_image(image_name=image_uri, template_path=template_path)
        if push_image:
            push_docker_image(image_uri=image_uri)

    config_file_name = (
            output_file if output_file is not None else "mlflow-serving-app-{model_id}.yaml".format(
                model_id=model_id))
    config_file_path = os.path.join(os.getcwd(), config_file_name)
    application_config = ApplicationConfig(
            model_path=model_path, image_uri=image_uri, run_id=run_id)
    application_config.save(path=config_file_path)
    print("Wrote application configuration to: {output_path}".format(output_path=config_file_path))

        
def _get_image_template(image_resources_path, model_path, run_id=None, pyfunc_uri=None, 
        mlflow_home=None):
    if pyfunc_uri is not None:
        dockerfile_cmds = ["FROM {base_uri}".format(base_uri=pyfunc_uri)]
    else:
        dockerfile_template = get_template(
                image_resources_path=image_resources_path, mlflow_home=mlflow_home)
        dockerfile_cmds = dockerfile_template.split("\n")

    if run_id:
        model_path = _get_model_log_dir(model_path, run_id)

    model_resource_path = _copy_file_or_tree(
            src=model_path, dst=image_resources_path, dst_dir="model")
         
    container_model_path = "/opt/ml/model"
    dockerfile_cmds.append("RUN rm -rf {container_model_path}".format(
        container_model_path=container_model_path))
    dockerfile_cmds.append("COPY {host_model_path} {container_model_path}".format(
        host_model_path=model_resource_path, container_model_path=container_model_path)) 
    return "\n".join(dockerfile_cmds)

    
def _get_model_id(run_id=None):
    from datetime import datetime
    timestamp_format = "%Y-%m-%d-%H-%M-%S"
    return "{rid}-{ts}".format(rid=(run_id if run_id is not None else "local"),
                               ts=datetime.now().strftime(timestamp_format))


def _get_deployment_config(app_name, image_uri, internal_port):
    return DEPLOYMENT_CONFIG_TEMPLATE.format(
            image_uri=image_uri, internal_port=internal_port, app_name=app_name)


def _get_service_config(app_name, service_type, service_port, internal_port):
    return SERVICE_CONFIG_TEMPLATE.format(
        service_type=service_type, service_port=service_port, internal_port=internal_port,
        app_name=app_name)


def _add_image_pull_secret(deployment_config, secret_name):
    """
    :param deployment_config: The deployment configuration string.
    :param secret_name: The name of the secret to add. 

    :return: The deployment configuration with the specified image pull secret.
    """
    parsed_config = yaml.safe_load(deployment_config)
    container_template_spec = parsed_config["spec"]["template"]["spec"]
    container_template_spec["imagePullSecrets"] = [{"name" : str(secret_name)}]
    return yaml.dump(parsed_config, default_flow_style=False)


def _load_kubernetes_config(config_path):
    """
    :param config_path: The absolute path to the configuration.
    """
    with open(config_path, "r") as f:
        return yaml.load(f)
