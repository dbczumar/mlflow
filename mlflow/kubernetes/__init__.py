import os
import yaml

import mlflow
from mlflow.tracking.utils import _get_model_log_dir
from mlflow.utils.file_utils import TempDir, _copy_file_or_tree 
from mlflow.utils.process import exec_cmd 
import mlflow.utils.docker as docker_utils

MODEL_SERVER_INTERNAL_PORT = 8080
DEFAULT_SERVICE_PORT = 5001

SERVICE_TYPE_LOAD_BALANCER = "LoadBalancer"
SERVICE_TYPE_NODE_PORT = "NodePort"
SERVICE_TYPE_CLUSTER_IP = "ClusterIP"

SERVICE_TYPES = [
    SERVICE_TYPE_LOAD_BALANCER,
    SERVICE_TYPE_NODE_PORT,
    SERVICE_TYPE_CLUSTER_IP
]

DEPLOYMENT_MODE_CREATE = "create"
DEPLOYMENT_MODE_REPLACE = "replace"

DEPLOYMENT_MODES = [
    DEPLOYMENT_MODE_CREATE,
    DEPLOYMENT_MODE_REPLACE
]

APPLICATION_CONFIG_SUBPATH = "server_config.yaml"

DEPLOYMENT_CONFIG_TEMPLATE = """\
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {app_name} 
  labels:
    app: {app_name} 
spec:
  replicas: {num_replicas} 
  selector:
    matchLabels:
      app: {app_name} 
  template:
    metadata:
      labels:
        app: {app_name} 
    spec:
      containers:
      - name: {app_name}
        image: {image_uri} 
        args: ["serve"]
        ports:
        - containerPort: {internal_port}
        imagePullPolicy: Always
        readinessProbe:
            httpGet:
                path: /ping
                port: {internal_port}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: {max_unavailable}
"""

SERVICE_CONFIG_TEMPLATE = """\
apiVersion: v1
kind: Service
metadata:
  name: {app_name}
spec:
  type: {service_type}
  selector:
    app: {app_name} 
  ports:
  - name: {app_name}-port
    protocol: TCP
    port: {service_port} 
    targetPort: {internal_port} 
"""

class DockerImage:

    def __init__(self, name, tag=None):
        self.name = name
        self.tag = tag

    def get_uri(self):
        if self.tag is None:
            return self.name
        else:
            return "{name}:{tag}".format(name=self.name, tag=self.tag)

    def __str__(self):
        return self.get_uri()

class ApplicationConfig:

    def __init__(self, model_path, image_uri, run_id=None):
        self.image_uri = image_uri
        self.model_path = model_path
        self.run_id = run_id
        
    def to_yaml(self, stream=None):
        return yaml.safe_dump(self.__dict__, stream=stream, default_flow_style=False)
    

    def save(self, path):
        with open(path, "w") as f:
            self.to_yaml(stream=f)


    @classmethod
    def load(cls, path):
        with open(path, "r") as f:
            return cls(**yaml.safe_load(f.read()))


def deploy(app_name, config_path, replicas=1, image_pull_secret=None, 
           service_type=SERVICE_TYPE_LOAD_BALANCER, service_port=None, mode=DEPLOYMENT_MODE_CREATE, 
           log_directory=None):
    """
    :param app_name: The name to give the deployed application. This will be used for naming the 
                     Kubernetes services and deployments that are created.
    :param config_path: The path to the model application configuration generated by 
                        `mlflow.kubernetes.build_serving_application`.
    :param replicas: The number of model replicas to deploy.
    :param image_pull_secret: The name of a Kubernetes secret that will be used to pull images
                              from the Docker registry specified by `target_registry_uri`.
    :param service_type: The type of Kubernetes service to use for exposing the model. This must be
                         one of the values specified `mlflow.kubernetes.SERVICE_TYPES`, which
                         correspond to Kubernetes service types outlined here:
                         https://kubernetes.io/docs/concepts/services-networking/service/
                         #publishing-services-service-types.
    :param service_port: The cluster node port on which to expose the Kubernetes service for model 
                         serving. This value will be used for the `port` field of the Kubernetes
                         service spec (see mlflow.kubernetes.SERVICE_CONFIG_TEMPLATE for reference).
                         If `None`, the port defined by `mlflow.kubernetes.DEFAULT_SERVICE_PORT`
                         will be used.
    :param mode: the mode in which to deploy the application. must be one of the following:

                 ``mlflow.kubernetes.DEPLOYMENT_MODE_CREATE``
                     create an application with the specified name and model. this fails if an
                     application of the same name already exists.

                 ``mlflow.kubernetes.DEPLOYMENT_MODE_REPLACE``
                     if an application of the specified name exists, its model replaced with
                     the specified model. if no such application exists, it is created with the
                     specified name and model.

    :param log_directory: If specified, Kubernetes configuration files generated during deployment
                          will be logged to this directory. The directory must not already exist. 
    """
    if service_type not in SERVICE_TYPES:
        raise Exception("The specified `service_type` value: `{specified_service_type}` is not"
                         " supported. the value must be one of: {supported_service_types}".format(
                             specified_service_type=service_type,
                             supported_service_types=SERVICE_TYPES))

    if mode not in DEPLOYMENT_MODES:
        raise ValueError("`mode` must be one of: {mds}".format(
            mds=DEPLOYMENT_MODES))

    application_config = ApplicationConfig.load(config_path)
    with TempDir() as tmp:
        cwd = tmp.path()

        deployment_config_path = os.path.join(
                cwd, "{app_name}_deployment_config.yaml".format(app_name=app_name))
        deployment_config = _get_deployment_config(
                app_name=app_name, image_uri=application_config.image_uri, 
                internal_port=MODEL_SERVER_INTERNAL_PORT, num_replicas=replicas)
        if image_pull_secret is not None:
            _add_image_pull_secret(
                    deployment_config=deployment_config, secret_name=image_pull_secret)
        with open(deployment_config_path, "w") as f:
            f.write(deployment_config)

        service_config_path = os.path.join(
                cwd, "{app_name}_service_config.yaml".format(app_name=app_name))
        service_port = service_port if service_port is not None else DEFAULT_SERVICE_PORT
        service_config = _get_service_config(
                app_name=app_name, service_type=service_type, service_port=service_port, 
                internal_port=MODEL_SERVER_INTERNAL_PORT)
        with open(service_config_path, "w") as f:
            f.write(service_config)

        if mode == DEPLOYMENT_MODE_CREATE:
            _create_app_deployment(deployment_config_path=deployment_config_path,
                                   service_config_path=service_config_path)
        elif mode == DEPLOYMENT_MODE_REPLACE:
            _update_app_deployment(deployment_config_path=deployment_config_path,
                                   service_config_path=service_config_path)

        if log_directory is not None:
            log_directory = os.path.abspath(log_directory)
            print("Logging generated Kubernetes configurations to: {log_directory}".format(
                log_directory=log_directory))
            os.makedirs(log_directory)
            _copy_file_or_tree(deployment_config_path, log_directory, None)
            _copy_file_or_tree(service_config_path, log_directory, None)


def _create_app_deployment(deployment_config_path, service_config_path):
    base_cmd = "kubectl create -f {config_path}"
    _execute_kubectl_command(
            cmd_template=base_cmd, config_path=deployment_config_path, stream_output=True)
    _execute_kubectl_command(
            cmd_template=base_cmd, config_path=service_config_path, stream_output=True)


def _update_app_deployment(deployment_config_path, service_config_path):
    base_cmd = "kubectl apply -f {config_path}"
    _execute_kubectl_command(
            cmd_template=base_cmd, config_path=deployment_config_path, stream_output=True)
    _execute_kubectl_command(
            cmd_template=base_cmd, config_path=service_config_path, stream_output=True)


def _get_active_container_image(app_name):
    _, active_deployments, _ = _execute_kubectl_command(
            "kubectl get deployment -o=yaml --export", stream_output=False)
    active_deployments = yaml.load(active_deployments)["items"]
    app_deployment = filter(
            lambda deployment_info : deployment_info["metadata"]["name"] == app_name, 
            active_deployments)
    if len(app_deployment) == 0:
        return None
    elif len(app_deployment) > 1:
        raise Exception("Unexpectedly found multiple deployments for the application named:" 
                        " {app_name}".format(app_name=app_name))
    else:
        app_deployment = app_deployment[0]
    
    app_containers = app_deployment["spec"]["template"]["spec"]["containers"]
    if len(app_containers) != 1:
        raise Exception(
                "Expected to find a single deployed container during update procedure." 
                " Found {active_containers} instead.".format(active_containers=len(app_containers)))
    active_image = app_containers[0]["image"]
    active_image = active_image.split(":")
    if len(active_image) > 1:
        return DockerImage(name=active_image[0], tag=active_image[1])
    else:
        return DockerImage(name=active_image[0], tag=None)


def _execute_kubectl_command(cmd_template, stream_output=False, **kwargs):
    cmd = cmd_template.format(**kwargs)
    print(cmd)
    return exec_cmd(cmd=cmd.split(" "), stream_output=stream_output)


def register_model_for_serving(model_path, run_id=None, pyfunc_image_uri=None, mlflow_home=None, 
                               image_name=None, target_registry_uri=None, push_image=False, 
                               output_file=None):
    """
    :param model_path: The path to the Mlflow model for which to build a server.
                       If `run_id` is not `None`, this should be an absolute path. Otherwise,
                       it should be a run-relative path.
    :param run_id: The run id of the Mlflow model for which to build a server.
    :param pyfunc_image_uri: URI of an `mlflow-pyfunc` base Docker image from which the model server 
                             Docker image will be built. If `None`, the base image will be
                             built from scratch.
    :param mlflow_home: Path to the Mlflow root directory. This will only be used if the container
                        base image is being built from scratch (if `pyfunc_image_uri` is `None`).
                        If `mlflow_home` is `None`, the base image will install Mlflow from pip
                        during the build. Otherwise, it will install Mlflow from the specified
                        directory.
    :param image_name: The name to give the application's model server Docker image. This may
                       include a version tag. If `None`, a name will be generated. 
    :param target_registry_uri: The URI of the docker registry that Kubernetes will use to
                                pull the application's model server Docker image. If `None`, the 
                                default docker registry (docker.io) will be used. Otherwise, the 
                                model server image will be tagged using the specified registry uri.
    :param push_image: If `True`, the model server Docker image will be pushed to the registry
                       specified by `target_registry_uri` (or docker.io if `target_registry_uri` is
                       `None`). If `False`, the model server Docker image will not be
                       pushed to a registry.
    :param output_file: The name of the configuration file containing application information.
                        If `None`, a name will be generated. 
    """
    with TempDir() as tmp:
        cwd = tmp.path()
        dockerfile_template = _get_image_template(image_resources_path=cwd, 
                model_path=model_path, run_id=run_id, pyfunc_uri=pyfunc_image_uri, 
                mlflow_home=mlflow_home)

        template_path = os.path.join(cwd, "Dockerfile")
        with open(template_path, "w") as f:
            f.write(dockerfile_template)
        
        model_id = _get_model_id(run_id=run_id)
        image_name = (image_name if image_name is not None else 
            "mlflow-model-{model_id}".format(model_id=model_id))
        if target_registry_uri is not None:
            image_uri = "/".join([target_registry_uri.strip("/"), image_name])
        else:
            image_uri = image_name
        
        docker_utils.build_image(image_name=image_uri, template_path=template_path)
        if push_image:
            docker_utils.push_image(image_uri=image_uri)

    config_file_name = (
            output_file if output_file is not None else "mlflow-serving-app-{model_id}.yaml".format(
                model_id=model_id))
    config_file_path = os.path.join(os.getcwd(), config_file_name)
    application_config = ApplicationConfig(
            model_path=model_path, image_uri=image_uri, run_id=run_id)
    application_config.save(path=config_file_path)
    print("Wrote registered model configuration to: {output_path}".format(
        output_path=config_file_path))

        
def _get_image_template(image_resources_path, model_path, run_id=None, pyfunc_uri=None, 
        mlflow_home=None):
    if pyfunc_uri is not None:
        dockerfile_cmds = ["FROM {base_uri}".format(base_uri=pyfunc_uri)]
    else:
        dockerfile_template = docker_utils.get_template(
                image_resources_path=image_resources_path, mlflow_home=mlflow_home)
        dockerfile_cmds = dockerfile_template.split("\n")

    if run_id:
        model_path = _get_model_log_dir(model_path, run_id)

    model_resource_path = _copy_file_or_tree(
            src=model_path, dst=image_resources_path, dst_dir="model")
         
    container_model_path = "/opt/ml/model"
    dockerfile_cmds.append("RUN rm -rf {container_model_path}".format(
        container_model_path=container_model_path))
    dockerfile_cmds.append("COPY {host_model_path} {container_model_path}".format(
        host_model_path=model_resource_path, container_model_path=container_model_path))
    dockerfile_cmds.append(
            "RUN python -c" 
            "\"import mlflow.kubernetes.container;"
            " mlflow.kubernetes.container.create_conda_env_if_necessary()\"")
    return "\n".join(dockerfile_cmds)

    
def _get_model_id(run_id=None):
    from datetime import datetime
    timestamp_format = "%Y-%m-%d-%H-%M-%S"
    return "{rid}-{ts}".format(rid=(run_id if run_id is not None else "local"),
                               ts=datetime.now().strftime(timestamp_format))


def _get_deployment_config(app_name, image_uri, internal_port, num_replicas):
    return DEPLOYMENT_CONFIG_TEMPLATE.format(
            image_uri=image_uri, internal_port=internal_port, app_name=app_name, 
            num_replicas=num_replicas, max_unavailable=num_replicas - 1)


def _get_service_config(app_name, service_type, service_port, internal_port):
    return SERVICE_CONFIG_TEMPLATE.format(
        service_type=service_type, service_port=service_port, internal_port=internal_port,
        app_name=app_name)


def _add_image_pull_secret(deployment_config, secret_name):
    """
    :param deployment_config: The deployment configuration string.
    :param secret_name: The name of the secret to add. 

    :return: The deployment configuration with the specified image pull secret.
    """
    parsed_config = yaml.safe_load(deployment_config)
    deployment_template_spec = parsed_config["spec"]["template"]["spec"]
    deployment_template_spec["imagePullSecrets"] = [{"name" : str(secret_name)}]
    return yaml.dump(parsed_config, default_flow_style=False)


def _set_image_uri(deployment_config, image_uri):
    """
    :param deployment_config: The deployment configuration string.
    :param image_uri: The URI of the container image to set. 

    :return: The deployment configuration with the specified container image URI.
    """
    parsed_config = yaml.safe_load(deployment_config)
    app_container_spec = parsed_config["spec"]["template"]["spec"]["containers"][0]
    app_container_spec["image"] = image_uri
    return yaml.dump(parsed_config, default_flow_style=False)


def _load_kubernetes_config(config_path):
    """
    :param config_path: The absolute path to the configuration.
    """
    with open(config_path, "r") as f:
        return yaml.load(f)
